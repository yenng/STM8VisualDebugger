/*
 * The Jintilla Project - This is a Java SWT port of Scintilla, a free source code editing component.
 * Copyright (C) 2005  Nathan Sweet
 * 
 * http://sourceforge.net/projects/jintilla
 * http://www.scintilla.org/
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package org.scintilla.editor;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;

import org.eclipse.swt.SWT;
import org.eclipse.swt.SWTError;
import org.eclipse.swt.events.ControlAdapter;
import org.eclipse.swt.events.ControlEvent;
import org.eclipse.swt.events.DisposeEvent;
import org.eclipse.swt.events.DisposeListener;
import org.eclipse.swt.events.FocusAdapter;
import org.eclipse.swt.events.FocusEvent;
import org.eclipse.swt.events.SelectionListener;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.TypedListener;

/**
 * The Scintilla source editor control (scintilla.org) as an SWT Component. Currently there is only a JNI implementation for
 * win32. Much of this file is autogenerated by JFacer.py to make upgrading to the latest version of Scintilla trivial.
 * @author Valentin Valchev <v_valchev at prosyst.bg>
 * @author Nathan Sweet <misc at n4te.com>
 */
public class Scintilla extends Composite {
	static {
		System.loadLibrary("scijni");
	}

	static private Hashtable instances = new Hashtable();

	private List notificationListeners = new ArrayList();
	private int scintillaHandle;

	public Scintilla (Composite parent, int style) {
		super(parent, style);

		scintillaHandle = createControl(handle);
		if (scintillaHandle == 0) SWT.error(SWT.ERROR_NO_HANDLES);
		instances.put(new Integer(scintillaHandle), this);

		addDisposeListener(new DisposeListener() {
			public void widgetDisposed (DisposeEvent evt) {
				Scintilla.this.widgetDisposed(evt);
			}
		});
		addControlListener(new ControlAdapter() {
			public void controlResized (ControlEvent evt) {
				Scintilla.this.controlResized(evt);
			}
		});
		addFocusListener(new FocusAdapter() {
			public void focusGained (FocusEvent e) {
				Scintilla.setFocus(scintillaHandle);
			}
		});
	}

	public void widgetDisposed (DisposeEvent evt) {
		instances.remove(new Integer(scintillaHandle));
		scintillaHandle = 0;
	}

	public void controlResized (ControlEvent evt) {
		Rectangle rect = getClientArea();
		resizeControl(scintillaHandle, rect.x, rect.y, rect.width, rect.height);
	}

	public void addSelectionListener (SelectionListener listener) {
		if (listener == null) throw new SWTError(SWT.ERROR_NULL_ARGUMENT);
		addListener(SWT.Selection, new TypedListener(listener));
	}

	public void setStyle (int style, int fore, int back) {
		setStyle(style, fore, back, 0, null);
	}

	public void setStyle (int style, int fore, int back, int size) {
		setStyle(style, fore, back, size, null);
	}

	public void setStyle (int style, int fore, int back, String font) {
		setStyle(style, fore, back, 0, font);
	}

	public void setStyle (int style, int fore, int back, int size, String font) {
		styleSetFore(style, fore);
		styleSetBack(style, back);
		if (size >= 1) styleSetSize(style, size);
		if (font != null && font.length() > 0) styleSetFont(style, font);
	}

	public void addNotificationListener (NotificationListener listener) {
		notificationListeners.add(listener);
	}

	public void removeNotificationListener (NotificationListener listener) {
		notificationListeners.remove(listener);
	}

	static private void dispatchNotificationEvent (int handle, NotificationEvent event) {
		Scintilla scintilla = (Scintilla)instances.get(new Integer(handle));
		if (scintilla == null) return;
		for (Iterator iter = scintilla.notificationListeners.iterator(); iter.hasNext();) {
			NotificationListener listener = (NotificationListener)iter.next();
			listener.handleNotificationEvent(event);
		}
	}

	static private native final int createControl (int controlHandle);

	static private native final void resizeControl (int handle, int x, int y, int width, int height);

	static private native final void setFocus (int handle);

	private native int sendMessage (int msg, int wparam, int lparam);

	private native int sendMessage (int msg, int wparam, String lparam);

	private native int sendMessage (int msg, String wparam, String lparam);

	private native int sendMessage (int msg, int wparam, CText lparam);

	private native int sendMessage (int msg, int wparam, TextRange lparam);

	private native int sendMessage (int msg, int wparam, FindText lparam);

	// BOZO - Test the convenience methods. May need to null terminate strings for some methods when assigning the text field
	// of a CString from C++.

	/**
	 * Add text to the document at current position. Convenience method.
	 */
	public void addText (String text) {
		sendMessage(2001, text.length(), text);
	}

	/**
	 * Find some text in the document. If end is -1 the search will continue to the end of the document. Convenience method.
	 */
	public int findText (int flags, String searchPattern, int start, int end) {
		if (end == -1) end = getTextLength();
		FindText findText = new FindText(searchPattern, start, end);
		return sendMessage(2150, flags, findText);
	}

	/**
	 * Retrieve the text of the line containing the caret. Convenience method.
	 */
	public String getCurLine () {
		int curLineLength = sendMessage(2027, 0, 0);
		CText ctext = new CText(curLineLength);
		getCurLine(curLineLength, ctext);
		return ctext.text;
	}

	/**
	 * Retrieve the contents of a line. Convenience method.
	 */
	public String getLine (int line) {
		int lineLength = sendMessage(2153, line, 0);
		CText ctext = new CText(lineLength);
		getLine(line, ctext);
		return ctext.text;
	}

	/**
	 * Retrieve the selected text. Convenience method.
	 */
	public String getSelText () {
		int selectedTextLength = sendMessage(2161, 0, 0);
		CText ctext = new CText(selectedTextLength);
		getSelText(ctext);
		return ctext.text;
	}

	/**
	 * Retrieve all the text in the document. Convenience method.
	 */
	public String getText () {
		int documentLength = getTextLength() + 1;
		CText ctext = new CText(documentLength);
		getText(documentLength, ctext);
		return ctext.text;
	}

	/**
	 * Retrieve a range of text. Convenience method.
	 */
	public String getTextRange (int start, int end) {
		TextRange textRange = new TextRange(start, end);
		getTextRange(textRange);
		return textRange.text;
	}

	/**
	 * Retrieve a range of text from the start position to the end of the document. Convenience method.
	 */
	public String getTextRange (int start) {
		int documentLength = getTextLength();
		TextRange textRange = new TextRange(start, -1, (documentLength - start) + 1);
		getTextRange(textRange);
		return textRange.text;
	}

	// ------------------------------------------------------
	// The rest of this file is autogenerated from JFacer.py.
	// ------------------------------------------------------

	// ++Autogenerated
	/**
	 * Add text to the document at current position.
	 */
	public void addText (int length, String text) {
		sendMessage(2001, length, text);
	}

	/**
	 * Add array of cells to document.
	 */
	public void addStyledText (int length, String/* cells */c) {
		sendMessage(2002, length, c);
	}

	/**
	 * Insert string at a position.
	 */
	public void insertText (int pos, String text) {
		sendMessage(2003, pos, text);
	}

	/**
	 * Delete all text in the document.
	 */
	public void clearAll () {
		sendMessage(2004, 0, 0);
	}

	/**
	 * Set all style bytes to 0, remove all folding information.
	 */
	public void clearDocumentStyle () {
		sendMessage(2005, 0, 0);
	}

	/**
	 * Returns the number of characters in the document.
	 */
	public int getLength () {
		return sendMessage(2006, 0, 0);
	}

	/**
	 * Returns the character byte at the position.
	 */
	public int getCharAt (int pos) {
		return sendMessage(2007, pos, 0);
	}

	/**
	 * Returns the position of the caret.
	 */
	public int getCurrentPos () {
		return sendMessage(2008, 0, 0);
	}

	/**
	 * Returns the position of the opposite end of the selection to the caret.
	 */
	public int getAnchor () {
		return sendMessage(2009, 0, 0);
	}

	/**
	 * Returns the style byte at the position.
	 */
	public int getStyleAt (int pos) {
		return sendMessage(2010, pos, 0);
	}

	/**
	 * Redoes the next action on the undo history.
	 */
	public void redo () {
		sendMessage(2011, 0, 0);
	}

	/**
	 * Choose between collecting actions into the undo history and discarding them.
	 */
	public void setUndoCollection (boolean collectUndo) {
		sendMessage(2012, (collectUndo == true) ? 1 : 0, 0);
	}

	/**
	 * Select all the text in the document.
	 */
	public void selectAll () {
		sendMessage(2013, 0, 0);
	}

	/**
	 * Remember the current position in the undo history as the position at which the document was saved.
	 */
	public void setSavePoint () {
		sendMessage(2014, 0, 0);
	}

	/**
	 * Retrieve a buffer of cells. Returns the number of bytes in the buffer not including terminating NULs. NOTE: You should
	 * pass zero as wParam.
	 */
	public int getStyledText (TextRange tr) {
		return sendMessage(2015, 0, tr);
	}

	/**
	 * Are there any redoable actions in the undo history?
	 */
	public boolean canRedo () {
		return sendMessage(2016, 0, 0) == 0 ? false : true;
	}

	/**
	 * Retrieve the line number at which a particular marker is located.
	 */
	public int markerLineFromHandle (int handle) {
		return sendMessage(2017, handle, 0);
	}

	/**
	 * Delete a marker.
	 */
	public void markerDeleteHandle (int handle) {
		sendMessage(2018, handle, 0);
	}

	/**
	 * Is undo history being collected?
	 */
	public boolean getUndoCollection () {
		return sendMessage(2019, 0, 0) == 0 ? false : true;
	}

	/**
	 * Are white space characters currently visible? Returns one of SCWS_* constants.
	 */
	public int getViewWS () {
		return sendMessage(2020, 0, 0);
	}

	/**
	 * Make white space characters invisible, always visible or visible outside indentation.
	 */
	public void setViewWS (int viewWS) {
		sendMessage(2021, viewWS, 0);
	}

	/**
	 * Find the position from a point within the window.
	 */
	public int positionFromPoint (int x, int y) {
		return sendMessage(2022, x, y);
	}

	/**
	 * Find the position from a point within the window but return INVALID_POSITION if not close to text.
	 */
	public int positionFromPointClose (int x, int y) {
		return sendMessage(2023, x, y);
	}

	/**
	 * Set caret to start of a line and ensure it is visible.
	 */
	public void gotoLine (int line) {
		sendMessage(2024, line, 0);
	}

	/**
	 * Set caret to a position and ensure it is visible.
	 */
	public void gotoPos (int pos) {
		sendMessage(2025, pos, 0);
	}

	/**
	 * Set the selection anchor to a position. The anchor is the opposite end of the selection from the caret.
	 */
	public void setAnchor (int posAnchor) {
		sendMessage(2026, posAnchor, 0);
	}

	/**
	 * Retrieve the text of the line containing the caret. Returns the index of the caret on the line.
	 */
	public int getCurLine (int length, CText text) {
		return sendMessage(2027, length, text);
	}

	/**
	 * Retrieve the position of the last correctly styled character.
	 */
	public int getEndStyled () {
		return sendMessage(2028, 0, 0);
	}

	/**
	 * Convert all line endings in the document to one mode.
	 */
	public void convertEOLs (int eolMode) {
		sendMessage(2029, eolMode, 0);
	}

	/**
	 * Retrieve the current end of line mode - one of CRLF, CR, or LF.
	 */
	public int getEOLMode () {
		return sendMessage(2030, 0, 0);
	}

	/**
	 * Set the current end of line mode.
	 */
	public void setEOLMode (int eolMode) {
		sendMessage(2031, eolMode, 0);
	}

	/**
	 * Set the current styling position to pos and the styling mask to mask. The styling mask can be used to protect some bits
	 * in each styling byte from modification.
	 */
	public void startStyling (int pos, int mask) {
		sendMessage(2032, pos, mask);
	}

	/**
	 * Change style from current styling position for length characters to a style and move the current styling position to
	 * after this newly styled segment.
	 */
	public void setStyling (int length, int style) {
		sendMessage(2033, length, style);
	}

	/**
	 * Is drawing done first into a buffer or direct to the screen?
	 */
	public boolean getBufferedDraw () {
		return sendMessage(2034, 0, 0) == 0 ? false : true;
	}

	/**
	 * If drawing is buffered then each line of text is drawn into a bitmap buffer before drawing it to the screen to avoid
	 * flicker.
	 */
	public void setBufferedDraw (boolean buffered) {
		sendMessage(2035, (buffered == true) ? 1 : 0, 0);
	}

	/**
	 * Change the visible size of a tab to be a multiple of the width of a space character.
	 */
	public void setTabWidth (int tabWidth) {
		sendMessage(2036, tabWidth, 0);
	}

	/**
	 * Retrieve the visible size of a tab.
	 */
	public int getTabWidth () {
		return sendMessage(2121, 0, 0);
	}

	/**
	 * Set the code page used to interpret the bytes of the document as characters. The SC_CP_UTF8 value can be used to enter
	 * Unicode mode.
	 */
	public void setScintillaCodePage (int codePage) {
		sendMessage(2037, codePage, 0);
	}

	/**
	 * In palette mode, Scintilla uses the environment's palette calls to display more colours. This may lead to ugly
	 * displays.
	 */
	public void setUsePalette (boolean usePalette) {
		sendMessage(2039, (usePalette == true) ? 1 : 0, 0);
	}

	/**
	 * Set the symbol used for a particular marker number.
	 */
	public void markerDefine (int markerNumber, int markerSymbol) {
		sendMessage(2040, markerNumber, markerSymbol);
	}

	/**
	 * Set the foreground colour used for a particular marker number.
	 */
	public void markerSetFore (int markerNumber, int fore) {
		sendMessage(2041, markerNumber, fore);
	}

	/**
	 * Set the background colour used for a particular marker number.
	 */
	public void markerSetBack (int markerNumber, int back) {
		sendMessage(2042, markerNumber, back);
	}

	/**
	 * Add a marker to a line, returning an ID which can be used to find or delete the marker.
	 */
	public int markerAdd (int line, int markerNumber) {
		return sendMessage(2043, line, markerNumber);
	}

	/**
	 * Delete a marker from a line.
	 */
	public void markerDelete (int line, int markerNumber) {
		sendMessage(2044, line, markerNumber);
	}

	/**
	 * Delete all markers with a particular number from all lines.
	 */
	public void markerDeleteAll (int markerNumber) {
		sendMessage(2045, markerNumber, 0);
	}

	/**
	 * Get a bit mask of all the markers set on a line.
	 */
	public int markerGet (int line) {
		return sendMessage(2046, line, 0);
	}

	/**
	 * Find the next line after lineStart that includes a marker in mask.
	 */
	public int markerNext (int lineStart, int markerMask) {
		return sendMessage(2047, lineStart, markerMask);
	}

	/**
	 * Find the previous line before lineStart that includes a marker in mask.
	 */
	public int markerPrevious (int lineStart, int markerMask) {
		return sendMessage(2048, lineStart, markerMask);
	}

	/**
	 * Define a marker from a pixmap.
	 */
	public void markerDefinePixmap (int markerNumber, String pixmap) {
		sendMessage(2049, markerNumber, pixmap);
	}

	/**
	 * Set a margin to be either numeric or symbolic.
	 */
	public void setMarginTypeN (int margin, int marginType) {
		sendMessage(2240, margin, marginType);
	}

	/**
	 * Retrieve the type of a margin.
	 */
	public int getMarginTypeN (int margin) {
		return sendMessage(2241, margin, 0);
	}

	/**
	 * Set the width of a margin to a width expressed in pixels.
	 */
	public void setMarginWidthN (int margin, int pixelWidth) {
		sendMessage(2242, margin, pixelWidth);
	}

	/**
	 * Retrieve the width of a margin in pixels.
	 */
	public int getMarginWidthN (int margin) {
		return sendMessage(2243, margin, 0);
	}

	/**
	 * Set a mask that determines which markers are displayed in a margin.
	 */
	public void setMarginMaskN (int margin, int mask) {
		sendMessage(2244, margin, mask);
	}

	/**
	 * Retrieve the marker mask of a margin.
	 */
	public int getMarginMaskN (int margin) {
		return sendMessage(2245, margin, 0);
	}

	/**
	 * Make a margin sensitive or insensitive to mouse clicks.
	 */
	public void setMarginSensitiveN (int margin, boolean sensitive) {
		sendMessage(2246, margin, (sensitive == true) ? 1 : 0);
	}

	/**
	 * Retrieve the mouse click sensitivity of a margin.
	 */
	public boolean getMarginSensitiveN (int margin) {
		return sendMessage(2247, margin, 0) == 0 ? false : true;
	}

	/**
	 * Clear all the styles and make equivalent to the global default style.
	 */
	public void styleClearAll () {
		sendMessage(2050, 0, 0);
	}

	/**
	 * Set the foreground colour of a style.
	 */
	public void styleSetFore (int style, int fore) {
		sendMessage(2051, style, fore);
	}

	/**
	 * Set the background colour of a style.
	 */
	public void styleSetBack (int style, int back) {
		sendMessage(2052, style, back);
	}

	/**
	 * Set a style to be bold or not.
	 */
	public void styleSetBold (int style, boolean bold) {
		sendMessage(2053, style, (bold == true) ? 1 : 0);
	}

	/**
	 * Set a style to be italic or not.
	 */
	public void styleSetItalic (int style, boolean italic) {
		sendMessage(2054, style, (italic == true) ? 1 : 0);
	}

	/**
	 * Set the size of characters of a style.
	 */
	public void styleSetSize (int style, int sizePoints) {
		sendMessage(2055, style, sizePoints);
	}

	/**
	 * Set the font of a style.
	 */
	public void styleSetFont (int style, String fontName) {
		sendMessage(2056, style, fontName);
	}

	/**
	 * Set a style to have its end of line filled or not.
	 */
	public void styleSetEOLFilled (int style, boolean filled) {
		sendMessage(2057, style, (filled == true) ? 1 : 0);
	}

	/**
	 * Reset the default style to its state at startup
	 */
	public void styleResetDefault () {
		sendMessage(2058, 0, 0);
	}

	/**
	 * Set a style to be underlined or not.
	 */
	public void styleSetUnderline (int style, boolean underline) {
		sendMessage(2059, style, (underline == true) ? 1 : 0);
	}

	/**
	 * Set a style to be mixed case, or to force upper or lower case.
	 */
	public void styleSetCase (int style, int caseForce) {
		sendMessage(2060, style, caseForce);
	}

	/**
	 * Set the character set of the font in a style.
	 */
	public void styleSetCharacterSet (int style, int characterSet) {
		sendMessage(2066, style, characterSet);
	}

	/**
	 * Set a style to be a hotspot or not.
	 */
	public void styleSetHotSpot (int style, boolean hotspot) {
		sendMessage(2409, style, (hotspot == true) ? 1 : 0);
	}

	/**
	 * Set the foreground colour of the selection and whether to use this setting.
	 */
	public void setSelFore (boolean useSetting, int fore) {
		sendMessage(2067, (useSetting == true) ? 1 : 0, fore);
	}

	/**
	 * Set the background colour of the selection and whether to use this setting.
	 */
	public void setSelBack (boolean useSetting, int back) {
		sendMessage(2068, (useSetting == true) ? 1 : 0, back);
	}

	/**
	 * Set the foreground colour of the caret.
	 */
	public void setCaretFore (int fore) {
		sendMessage(2069, fore, 0);
	}

	/**
	 * When key+modifier combination km is pressed perform msg.
	 */
	public void assignCmdKey (int km, int msg) {
		sendMessage(2070, km, msg);
	}

	/**
	 * When key+modifier combination km is pressed do nothing.
	 */
	public void clearCmdKey (int km) {
		sendMessage(2071, km, 0);
	}

	/**
	 * Drop all key mappings.
	 */
	public void clearAllCmdKeys () {
		sendMessage(2072, 0, 0);
	}

	/**
	 * Set the styles for a segment of the document.
	 */
	public void setStylingEx (int length, String styles) {
		sendMessage(2073, length, styles);
	}

	/**
	 * Set a style to be visible or not.
	 */
	public void styleSetVisible (int style, boolean visible) {
		sendMessage(2074, style, (visible == true) ? 1 : 0);
	}

	/**
	 * Get the time in milliseconds that the caret is on and off.
	 */
	public int getCaretPeriod () {
		return sendMessage(2075, 0, 0);
	}

	/**
	 * Get the time in milliseconds that the caret is on and off. 0 = steady on.
	 */
	public void setCaretPeriod (int periodMilliseconds) {
		sendMessage(2076, periodMilliseconds, 0);
	}

	/**
	 * Set the set of characters making up words for when moving or selecting by word. First sets deaults like
	 * SetCharsDefault. NOTE: You should pass zero as wParam.
	 */
	public void setWordChars (String characters) {
		sendMessage(2077, 0, characters);
	}

	/**
	 * Start a sequence of actions that is undone and redone as a unit. May be nested.
	 */
	public void beginUndoAction () {
		sendMessage(2078, 0, 0);
	}

	/**
	 * End a sequence of actions that is undone and redone as a unit.
	 */
	public void endUndoAction () {
		sendMessage(2079, 0, 0);
	}

	/**
	 * Set an indicator to plain, squiggle or TT.
	 */
	public void indicSetStyle (int indic, int style) {
		sendMessage(2080, indic, style);
	}

	/**
	 * Retrieve the style of an indicator.
	 */
	public int indicGetStyle (int indic) {
		return sendMessage(2081, indic, 0);
	}

	/**
	 * Set the foreground colour of an indicator.
	 */
	public void indicSetFore (int indic, int fore) {
		sendMessage(2082, indic, fore);
	}

	/**
	 * Retrieve the foreground colour of an indicator.
	 */
	public int indicGetFore (int indic) {
		return sendMessage(2083, indic, 0);
	}

	/**
	 * Set the foreground colour of all whitespace and whether to use this setting.
	 */
	public void setWhitespaceFore (boolean useSetting, int fore) {
		sendMessage(2084, (useSetting == true) ? 1 : 0, fore);
	}

	/**
	 * Set the background colour of all whitespace and whether to use this setting.
	 */
	public void setWhitespaceBack (boolean useSetting, int back) {
		sendMessage(2085, (useSetting == true) ? 1 : 0, back);
	}

	/**
	 * Divide each styling byte into lexical class bits (default: 5) and indicator bits (default: 3). If a lexer requires more
	 * than 32 lexical states, then this is used to expand the possible states.
	 */
	public void setStyleBits (int bits) {
		sendMessage(2090, bits, 0);
	}

	/**
	 * Retrieve number of bits in style bytes used to hold the lexical state.
	 */
	public int getStyleBits () {
		return sendMessage(2091, 0, 0);
	}

	/**
	 * Used to hold extra styling information for each line.
	 */
	public void setLineState (int line, int state) {
		sendMessage(2092, line, state);
	}

	/**
	 * Retrieve the extra styling information for a line.
	 */
	public int getLineState (int line) {
		return sendMessage(2093, line, 0);
	}

	/**
	 * Retrieve the last line number that has line state.
	 */
	public int getMaxLineState () {
		return sendMessage(2094, 0, 0);
	}

	/**
	 * Is the background of the line containing the caret in a different colour?
	 */
	public boolean getCaretLineVisible () {
		return sendMessage(2095, 0, 0) == 0 ? false : true;
	}

	/**
	 * Display the background of the line containing the caret in a different colour.
	 */
	public void setCaretLineVisible (boolean show) {
		sendMessage(2096, (show == true) ? 1 : 0, 0);
	}

	/**
	 * Get the colour of the background of the line containing the caret.
	 */
	public int getCaretLineBack () {
		return sendMessage(2097, 0, 0);
	}

	/**
	 * Set the colour of the background of the line containing the caret.
	 */
	public void setCaretLineBack (int back) {
		sendMessage(2098, back, 0);
	}

	/**
	 * Set a style to be changeable or not (read only). Experimental feature, currently buggy.
	 */
	public void styleSetChangeable (int style, boolean changeable) {
		sendMessage(2099, style, (changeable == true) ? 1 : 0);
	}

	/**
	 * Display a auto-completion list. The lenEntered parameter indicates how many characters before the caret should be used
	 * to provide context.
	 */
	public void autoCShow (int lenEntered, String itemList) {
		sendMessage(2100, lenEntered, itemList);
	}

	/**
	 * Remove the auto-completion list from the screen.
	 */
	public void autoCCancel () {
		sendMessage(2101, 0, 0);
	}

	/**
	 * Is there an auto-completion list visible?
	 */
	public boolean autoCActive () {
		return sendMessage(2102, 0, 0) == 0 ? false : true;
	}

	/**
	 * Retrieve the position of the caret when the auto-completion list was displayed.
	 */
	public int autoCPosStart () {
		return sendMessage(2103, 0, 0);
	}

	/**
	 * User has selected an item so remove the list and insert the selection.
	 */
	public void autoCComplete () {
		sendMessage(2104, 0, 0);
	}

	/**
	 * Define a set of character that when typed cancel the auto-completion list. NOTE: You should pass zero as wParam.
	 */
	public void autoCStops (String characterSet) {
		sendMessage(2105, 0, characterSet);
	}

	/**
	 * Change the separator character in the string setting up an auto-completion list. Default is space but can be changed if
	 * items contain space.
	 */
	public void autoCSetSeparator (int separatorCharacter) {
		sendMessage(2106, separatorCharacter, 0);
	}

	/**
	 * Retrieve the auto-completion list separator character.
	 */
	public int autoCGetSeparator () {
		return sendMessage(2107, 0, 0);
	}

	/**
	 * Select the item in the auto-completion list that starts with a string. NOTE: You should pass zero as wParam.
	 */
	public void autoCSelect (String text) {
		sendMessage(2108, 0, text);
	}

	/**
	 * Should the auto-completion list be cancelled if the user backspaces to a position before where the box was created.
	 */
	public void autoCSetCancelAtStart (boolean cancel) {
		sendMessage(2110, (cancel == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve whether auto-completion cancelled by backspacing before start.
	 */
	public boolean autoCGetCancelAtStart () {
		return sendMessage(2111, 0, 0) == 0 ? false : true;
	}

	/**
	 * Define a set of characters that when typed will cause the autocompletion to choose the selected item. NOTE: You should
	 * pass zero as wParam.
	 */
	public void autoCSetFillUps (String characterSet) {
		sendMessage(2112, 0, characterSet);
	}

	/**
	 * Should a single item auto-completion list automatically choose the item.
	 */
	public void autoCSetChooseSingle (boolean chooseSingle) {
		sendMessage(2113, (chooseSingle == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve whether a single item auto-completion list automatically choose the item.
	 */
	public boolean autoCGetChooseSingle () {
		return sendMessage(2114, 0, 0) == 0 ? false : true;
	}

	/**
	 * Set whether case is significant when performing auto-completion searches.
	 */
	public void autoCSetIgnoreCase (boolean ignoreCase) {
		sendMessage(2115, (ignoreCase == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve state of ignore case flag.
	 */
	public boolean autoCGetIgnoreCase () {
		return sendMessage(2116, 0, 0) == 0 ? false : true;
	}

	/**
	 * Display a list of strings and send notification when user chooses one.
	 */
	public void userListShow (int listType, String itemList) {
		sendMessage(2117, listType, itemList);
	}

	/**
	 * Set whether or not autocompletion is hidden automatically when nothing matches.
	 */
	public void autoCSetAutoHide (boolean autoHide) {
		sendMessage(2118, (autoHide == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve whether or not autocompletion is hidden automatically when nothing matches.
	 */
	public boolean autoCGetAutoHide () {
		return sendMessage(2119, 0, 0) == 0 ? false : true;
	}

	/**
	 * Set whether or not autocompletion deletes any word characters after the inserted text upon completion.
	 */
	public void autoCSetDropRestOfWord (boolean dropRestOfWord) {
		sendMessage(2270, (dropRestOfWord == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve whether or not autocompletion deletes any word characters after the inserted text upon completion.
	 */
	public boolean autoCGetDropRestOfWord () {
		return sendMessage(2271, 0, 0) == 0 ? false : true;
	}

	/**
	 * Register an XPM image for use in autocompletion lists.
	 */
	public void registerImage (int type, String xpmData) {
		sendMessage(2405, type, xpmData);
	}

	/**
	 * Clear all the registered XPM images.
	 */
	public void clearRegisteredImages () {
		sendMessage(2408, 0, 0);
	}

	/**
	 * Retrieve the auto-completion list type-separator character.
	 */
	public int autoCGetTypeSeparator () {
		return sendMessage(2285, 0, 0);
	}

	/**
	 * Change the type-separator character in the string setting up an auto-completion list. Default is '?' but can be changed
	 * if items contain '?'.
	 */
	public void autoCSetTypeSeparator (int separatorCharacter) {
		sendMessage(2286, separatorCharacter, 0);
	}

	/**
	 * Set the number of spaces used for one level of indentation.
	 */
	public void setIndent (int indentSize) {
		sendMessage(2122, indentSize, 0);
	}

	/**
	 * Retrieve indentation size.
	 */
	public int getIndent () {
		return sendMessage(2123, 0, 0);
	}

	/**
	 * Indentation will only use space characters if useTabs is false, otherwise it will use a combination of tabs and spaces.
	 */
	public void setUseTabs (boolean useTabs) {
		sendMessage(2124, (useTabs == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve whether tabs will be used in indentation.
	 */
	public boolean getUseTabs () {
		return sendMessage(2125, 0, 0) == 0 ? false : true;
	}

	/**
	 * Change the indentation of a line to a number of columns.
	 */
	public void setLineIndentation (int line, int indentSize) {
		sendMessage(2126, line, indentSize);
	}

	/**
	 * Retrieve the number of columns that a line is indented.
	 */
	public int getLineIndentation (int line) {
		return sendMessage(2127, line, 0);
	}

	/**
	 * Retrieve the position before the first non indentation character on a line.
	 */
	public int getLineIndentPosition (int line) {
		return sendMessage(2128, line, 0);
	}

	/**
	 * Retrieve the column number of a position, taking tab width into account.
	 */
	public int getColumn (int pos) {
		return sendMessage(2129, pos, 0);
	}

	/**
	 * Show or hide the horizontal scroll bar.
	 */
	public void setHScrollBar (boolean show) {
		sendMessage(2130, (show == true) ? 1 : 0, 0);
	}

	/**
	 * Is the horizontal scroll bar visible?
	 */
	public boolean getHScrollBar () {
		return sendMessage(2131, 0, 0) == 0 ? false : true;
	}

	/**
	 * Show or hide indentation guides.
	 */
	public void setIndentationGuides (boolean show) {
		sendMessage(2132, (show == true) ? 1 : 0, 0);
	}

	/**
	 * Are the indentation guides visible?
	 */
	public boolean getIndentationGuides () {
		return sendMessage(2133, 0, 0) == 0 ? false : true;
	}

	/**
	 * Set the highlighted indentation guide column. 0 = no highlighted guide.
	 */
	public void setHighlightGuide (int column) {
		sendMessage(2134, column, 0);
	}

	/**
	 * Get the highlighted indentation guide column.
	 */
	public int getHighlightGuide () {
		return sendMessage(2135, 0, 0);
	}

	/**
	 * Get the position after the last visible characters on a line.
	 */
	public int getLineEndPosition (int line) {
		return sendMessage(2136, line, 0);
	}

	/**
	 * Get the code page used to interpret the bytes of the document as characters.
	 */
	public int getScintillaCodePage () {
		return sendMessage(2137, 0, 0);
	}

	/**
	 * Get the foreground colour of the caret.
	 */
	public int getCaretFore () {
		return sendMessage(2138, 0, 0);
	}

	/**
	 * In palette mode?
	 */
	public boolean getUsePalette () {
		return sendMessage(2139, 0, 0) == 0 ? false : true;
	}

	/**
	 * In read-only mode?
	 */
	public boolean getReadOnly () {
		return sendMessage(2140, 0, 0) == 0 ? false : true;
	}

	/**
	 * Sets the position of the caret.
	 */
	public void setCurrentPos (int pos) {
		sendMessage(2141, pos, 0);
	}

	/**
	 * Sets the position that starts the selection - this becomes the anchor.
	 */
	public void setSelectionStart (int pos) {
		sendMessage(2142, pos, 0);
	}

	/**
	 * Returns the position at the start of the selection.
	 */
	public int getSelectionStart () {
		return sendMessage(2143, 0, 0);
	}

	/**
	 * Sets the position that ends the selection - this becomes the currentPosition.
	 */
	public void setSelectionEnd (int pos) {
		sendMessage(2144, pos, 0);
	}

	/**
	 * Returns the position at the end of the selection.
	 */
	public int getSelectionEnd () {
		return sendMessage(2145, 0, 0);
	}

	/**
	 * Sets the print magnification added to the point size of each style for printing.
	 */
	public void setPrintMagnification (int magnification) {
		sendMessage(2146, magnification, 0);
	}

	/**
	 * Returns the print magnification.
	 */
	public int getPrintMagnification () {
		return sendMessage(2147, 0, 0);
	}

	/**
	 * Modify colours when printing for clearer printed text.
	 */
	public void setPrintColourMode (int mode) {
		sendMessage(2148, mode, 0);
	}

	/**
	 * Returns the print colour mode.
	 */
	public int getPrintColourMode () {
		return sendMessage(2149, 0, 0);
	}

	/**
	 * Find some text in the document.
	 */
	public int findText (int flags, FindText ft) {
		return sendMessage(2150, flags, ft);
	}

	/**
	 * Retrieve the display line at the top of the display.
	 */
	public int getFirstVisibleLine () {
		return sendMessage(2152, 0, 0);
	}

	/**
	 * Retrieve the contents of a line. Returns the length of the line.
	 */
	public int getLine (int line, CText text) {
		return sendMessage(2153, line, text);
	}

	/**
	 * Returns the number of lines in the document. There is always at least one.
	 */
	public int getLineCount () {
		return sendMessage(2154, 0, 0);
	}

	/**
	 * Sets the size in pixels of the left margin. NOTE: You should pass zero as wParam.
	 */
	public void setMarginLeft (int pixelWidth) {
		sendMessage(2155, 0, pixelWidth);
	}

	/**
	 * Returns the size in pixels of the left margin.
	 */
	public int getMarginLeft () {
		return sendMessage(2156, 0, 0);
	}

	/**
	 * Sets the size in pixels of the right margin. NOTE: You should pass zero as wParam.
	 */
	public void setMarginRight (int pixelWidth) {
		sendMessage(2157, 0, pixelWidth);
	}

	/**
	 * Returns the size in pixels of the right margin.
	 */
	public int getMarginRight () {
		return sendMessage(2158, 0, 0);
	}

	/**
	 * Is the document different from when it was last saved?
	 */
	public boolean getModify () {
		return sendMessage(2159, 0, 0) == 0 ? false : true;
	}

	/**
	 * Select a range of text.
	 */
	public void setSel (int start, int end) {
		sendMessage(2160, start, end);
	}

	/**
	 * Retrieve the selected text. Return the length of the text. NOTE: You should pass zero as wParam.
	 */
	public int getSelText (CText text) {
		return sendMessage(2161, 0, text);
	}

	/**
	 * Retrieve a range of text. Return the length of the text. NOTE: You should pass zero as wParam.
	 */
	public int getTextRange (TextRange tr) {
		return sendMessage(2162, 0, tr);
	}

	/**
	 * Draw the selection in normal style or with selection highlighted.
	 */
	public void hideSelection (boolean normal) {
		sendMessage(2163, (normal == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve the x value of the point in the window where a position is displayed. NOTE: You should pass zero as wParam.
	 */
	public int pointXFromPosition (int pos) {
		return sendMessage(2164, 0, pos);
	}

	/**
	 * Retrieve the y value of the point in the window where a position is displayed. NOTE: You should pass zero as wParam.
	 */
	public int pointYFromPosition (int pos) {
		return sendMessage(2165, 0, pos);
	}

	/**
	 * Retrieve the line containing a position.
	 */
	public int lineFromPosition (int pos) {
		return sendMessage(2166, pos, 0);
	}

	/**
	 * Retrieve the position at the start of a line.
	 */
	public int positionFromLine (int line) {
		return sendMessage(2167, line, 0);
	}

	/**
	 * Scroll horizontally and vertically.
	 */
	public void lineScroll (int columns, int lines) {
		sendMessage(2168, columns, lines);
	}

	/**
	 * Ensure the caret is visible.
	 */
	public void scrollCaret () {
		sendMessage(2169, 0, 0);
	}

	/**
	 * Replace the selected text with the argument text. NOTE: You should pass zero as wParam.
	 */
	public void replaceSel (String text) {
		sendMessage(2170, 0, text);
	}

	/**
	 * Set to read only or read write.
	 */
	public void setReadOnly (boolean readOnly) {
		sendMessage(2171, (readOnly == true) ? 1 : 0, 0);
	}

	/**
	 * Null operation.
	 */
	public void nullOperation () {
		sendMessage(2172, 0, 0);
	}

	/**
	 * Will a paste succeed?
	 */
	public boolean canPaste () {
		return sendMessage(2173, 0, 0) == 0 ? false : true;
	}

	/**
	 * Are there any undoable actions in the undo history?
	 */
	public boolean canUndo () {
		return sendMessage(2174, 0, 0) == 0 ? false : true;
	}

	/**
	 * Delete the undo history.
	 */
	public void emptyUndoBuffer () {
		sendMessage(2175, 0, 0);
	}

	/**
	 * Undo one action in the undo history.
	 */
	public void undo () {
		sendMessage(2176, 0, 0);
	}

	/**
	 * Cut the selection to the clipboard.
	 */
	public void cut () {
		sendMessage(2177, 0, 0);
	}

	/**
	 * Copy the selection to the clipboard.
	 */
	public void copy () {
		sendMessage(2178, 0, 0);
	}

	/**
	 * Paste the contents of the clipboard into the document replacing the selection.
	 */
	public void paste () {
		sendMessage(2179, 0, 0);
	}

	/**
	 * Clear the selection.
	 */
	public void clear () {
		sendMessage(2180, 0, 0);
	}

	/**
	 * Replace the contents of the document with the argument text. NOTE: You should pass zero as wParam.
	 */
	public void setText (String text) {
		sendMessage(2181, 0, text);
	}

	/**
	 * Retrieve all the text in the document. Returns number of characters retrieved.
	 */
	public int getText (int length, CText text) {
		return sendMessage(2182, length, text);
	}

	/**
	 * Retrieve the number of characters in the document.
	 */
	public int getTextLength () {
		return sendMessage(2183, 0, 0);
	}

	/**
	 * Retrieve a pointer to a function that processes messages for this Scintilla.
	 */
	public int getDirectFunction () {
		return sendMessage(2184, 0, 0);
	}

	/**
	 * Retrieve a pointer value to use as the first argument when calling the function returned by GetDirectFunction.
	 */
	public int getDirectPointer () {
		return sendMessage(2185, 0, 0);
	}

	/**
	 * Set to overtype (true) or insert mode.
	 */
	public void setOvertype (boolean overtype) {
		sendMessage(2186, (overtype == true) ? 1 : 0, 0);
	}

	/**
	 * Returns true if overtype mode is active otherwise false is returned.
	 */
	public boolean getOvertype () {
		return sendMessage(2187, 0, 0) == 0 ? false : true;
	}

	/**
	 * Set the width of the insert mode caret.
	 */
	public void setCaretWidth (int pixelWidth) {
		sendMessage(2188, pixelWidth, 0);
	}

	/**
	 * Returns the width of the insert mode caret.
	 */
	public int getCaretWidth () {
		return sendMessage(2189, 0, 0);
	}

	/**
	 * Sets the position that starts the target which is used for updating the document without affecting the scroll position.
	 */
	public void setTargetStart (int pos) {
		sendMessage(2190, pos, 0);
	}

	/**
	 * Get the position that starts the target.
	 */
	public int getTargetStart () {
		return sendMessage(2191, 0, 0);
	}

	/**
	 * Sets the position that ends the target which is used for updating the document without affecting the scroll position.
	 */
	public void setTargetEnd (int pos) {
		sendMessage(2192, pos, 0);
	}

	/**
	 * Get the position that ends the target.
	 */
	public int getTargetEnd () {
		return sendMessage(2193, 0, 0);
	}

	/**
	 * Replace the target text with the argument text. Text is counted so it can contain NULs. Returns the length of the
	 * replacement text.
	 */
	public int replaceTarget (int length, String text) {
		return sendMessage(2194, length, text);
	}

	/**
	 * Replace the target text with the argument text after \d processing. Text is counted so it can contain NULs. Looks for
	 * \d where d is between 1 and 9 and replaces these with the strings matched in the last search operation which were
	 * surrounded by \( and \). Returns the length of the replacement text including any change caused by processing the \d
	 * patterns.
	 */
	public int replaceTargetRE (int length, String text) {
		return sendMessage(2195, length, text);
	}

	/**
	 * Search for a counted string in the target and set the target to the found range. Text is counted so it can contain
	 * NULs. Returns length of range or -1 for failure in which case target is not moved.
	 */
	public int searchInTarget (int length, String text) {
		return sendMessage(2197, length, text);
	}

	/**
	 * Set the search flags used by SearchInTarget.
	 */
	public void setSearchFlags (int flags) {
		sendMessage(2198, flags, 0);
	}

	/**
	 * Get the search flags used by SearchInTarget.
	 */
	public int getSearchFlags () {
		return sendMessage(2199, 0, 0);
	}

	/**
	 * Show a call tip containing a definition near position pos.
	 */
	public void callTipShow (int pos, String definition) {
		sendMessage(2200, pos, definition);
	}

	/**
	 * Remove the call tip from the screen.
	 */
	public void callTipCancel () {
		sendMessage(2201, 0, 0);
	}

	/**
	 * Is there an active call tip?
	 */
	public boolean callTipActive () {
		return sendMessage(2202, 0, 0) == 0 ? false : true;
	}

	/**
	 * Retrieve the position where the caret was before displaying the call tip.
	 */
	public int callTipPosStart () {
		return sendMessage(2203, 0, 0);
	}

	/**
	 * Highlight a segment of the definition.
	 */
	public void callTipSetHlt (int start, int end) {
		sendMessage(2204, start, end);
	}

	/**
	 * Set the background colour for the call tip.
	 */
	public void callTipSetBack (int back) {
		sendMessage(2205, back, 0);
	}

	/**
	 * Set the foreground colour for the call tip.
	 */
	public void callTipSetFore (int fore) {
		sendMessage(2206, fore, 0);
	}

	/**
	 * Set the foreground colour for the highlighted part of the call tip.
	 */
	public void callTipSetForeHlt (int fore) {
		sendMessage(2207, fore, 0);
	}

	/**
	 * Find the display line of a document line taking hidden lines into account.
	 */
	public int visibleFromDocLine (int line) {
		return sendMessage(2220, line, 0);
	}

	/**
	 * Find the document line of a display line taking hidden lines into account.
	 */
	public int docLineFromVisible (int lineDisplay) {
		return sendMessage(2221, lineDisplay, 0);
	}

	/**
	 * Set the fold level of a line. This encodes an integer level along with flags indicating whether the line is a header
	 * and whether it is effectively white space.
	 */
	public void setFoldLevel (int line, int level) {
		sendMessage(2222, line, level);
	}

	/**
	 * Retrieve the fold level of a line.
	 */
	public int getFoldLevel (int line) {
		return sendMessage(2223, line, 0);
	}

	/**
	 * Find the last child line of a header line.
	 */
	public int getLastChild (int line, int level) {
		return sendMessage(2224, line, level);
	}

	/**
	 * Find the parent line of a child line.
	 */
	public int getFoldParent (int line) {
		return sendMessage(2225, line, 0);
	}

	/**
	 * Make a range of lines visible.
	 */
	public void showLines (int lineStart, int lineEnd) {
		sendMessage(2226, lineStart, lineEnd);
	}

	/**
	 * Make a range of lines invisible.
	 */
	public void hideLines (int lineStart, int lineEnd) {
		sendMessage(2227, lineStart, lineEnd);
	}

	/**
	 * Is a line visible?
	 */
	public boolean getLineVisible (int line) {
		return sendMessage(2228, line, 0) == 0 ? false : true;
	}

	/**
	 * Show the children of a header line.
	 */
	public void setFoldExpanded (int line, boolean expanded) {
		sendMessage(2229, line, (expanded == true) ? 1 : 0);
	}

	/**
	 * Is a header line expanded?
	 */
	public boolean getFoldExpanded (int line) {
		return sendMessage(2230, line, 0) == 0 ? false : true;
	}

	/**
	 * Switch a header line between expanded and contracted.
	 */
	public void toggleFold (int line) {
		sendMessage(2231, line, 0);
	}

	/**
	 * Ensure a particular line is visible by expanding any header line hiding it.
	 */
	public void ensureVisible (int line) {
		sendMessage(2232, line, 0);
	}

	/**
	 * Set some style options for folding.
	 */
	public void setFoldFlags (int flags) {
		sendMessage(2233, flags, 0);
	}

	/**
	 * Ensure a particular line is visible by expanding any header line hiding it. Use the currently set visibility policy to
	 * determine which range to display.
	 */
	public void ensureVisibleEnforcePolicy (int line) {
		sendMessage(2234, line, 0);
	}

	/**
	 * Sets whether a tab pressed when caret is within indentation indents.
	 */
	public void setTabIndents (boolean tabIndents) {
		sendMessage(2260, (tabIndents == true) ? 1 : 0, 0);
	}

	/**
	 * Does a tab pressed when caret is within indentation indent?
	 */
	public boolean getTabIndents () {
		return sendMessage(2261, 0, 0) == 0 ? false : true;
	}

	/**
	 * Sets whether a backspace pressed when caret is within indentation unindents.
	 */
	public void setBackSpaceUnIndents (boolean bsUnIndents) {
		sendMessage(2262, (bsUnIndents == true) ? 1 : 0, 0);
	}

	/**
	 * Does a backspace pressed when caret is within indentation unindent?
	 */
	public boolean getBackSpaceUnIndents () {
		return sendMessage(2263, 0, 0) == 0 ? false : true;
	}

	/**
	 * Sets the time the mouse must sit still to generate a mouse dwell event.
	 */
	public void setMouseDwellTime (int periodMilliseconds) {
		sendMessage(2264, periodMilliseconds, 0);
	}

	/**
	 * Retrieve the time the mouse must sit still to generate a mouse dwell event.
	 */
	public int getMouseDwellTime () {
		return sendMessage(2265, 0, 0);
	}

	/**
	 * Get position of start of word.
	 */
	public int wordStartPosition (int pos, boolean onlyWordCharacters) {
		return sendMessage(2266, pos, (onlyWordCharacters == true) ? 1 : 0);
	}

	/**
	 * Get position of end of word.
	 */
	public int wordEndPosition (int pos, boolean onlyWordCharacters) {
		return sendMessage(2267, pos, (onlyWordCharacters == true) ? 1 : 0);
	}

	/**
	 * Sets whether text is word wrapped.
	 */
	public void setWrapMode (int mode) {
		sendMessage(2268, mode, 0);
	}

	/**
	 * Retrieve whether text is word wrapped.
	 */
	public int getWrapMode () {
		return sendMessage(2269, 0, 0);
	}

	/**
	 * Set the display mode of visual flags for wrapped lines.
	 */
	public void setWrapVisualFlags (int wrapVisualFlags) {
		sendMessage(2460, wrapVisualFlags, 0);
	}

	/**
	 * Retrive the display mode of visual flags for wrapped lines.
	 */
	public int getWrapVisualFlags () {
		return sendMessage(2461, 0, 0);
	}

	/**
	 * Set the location of visual flags for wrapped lines.
	 */
	public void setWrapVisualFlagsLocation (int wrapVisualFlagsLocation) {
		sendMessage(2462, wrapVisualFlagsLocation, 0);
	}

	/**
	 * Retrive the location of visual flags for wrapped lines.
	 */
	public int getWrapVisualFlagsLocation () {
		return sendMessage(2463, 0, 0);
	}

	/**
	 * Set the start indent for wrapped lines.
	 */
	public void setWrapStartIndent (int indent) {
		sendMessage(2464, indent, 0);
	}

	/**
	 * Retrive the start indent for wrapped lines.
	 */
	public int getWrapStartIndent () {
		return sendMessage(2465, 0, 0);
	}

	/**
	 * Sets the degree of caching of layout information.
	 */
	public void setLayoutCache (int mode) {
		sendMessage(2272, mode, 0);
	}

	/**
	 * Retrieve the degree of caching of layout information.
	 */
	public int getLayoutCache () {
		return sendMessage(2273, 0, 0);
	}

	/**
	 * Sets the document width assumed for scrolling.
	 */
	public void setScrollWidth (int pixelWidth) {
		sendMessage(2274, pixelWidth, 0);
	}

	/**
	 * Retrieve the document width assumed for scrolling.
	 */
	public int getScrollWidth () {
		return sendMessage(2275, 0, 0);
	}

	/**
	 * Measure the pixel width of some text in a particular style. NUL terminated text argument. Does not handle tab or
	 * control characters.
	 */
	public int textWidth (int style, String text) {
		return sendMessage(2276, style, text);
	}

	/**
	 * Sets the scroll range so that maximum scroll position has the last line at the bottom of the view (default). Setting
	 * this to false allows scrolling one page below the last line.
	 */
	public void setEndAtLastLine (boolean endAtLastLine) {
		sendMessage(2277, (endAtLastLine == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve whether the maximum scroll position has the last line at the bottom of the view.
	 */
	public int getEndAtLastLine () {
		return sendMessage(2278, 0, 0);
	}

	/**
	 * Retrieve the height of a particular line of text in pixels.
	 */
	public int textHeight (int line) {
		return sendMessage(2279, line, 0);
	}

	/**
	 * Show or hide the vertical scroll bar.
	 */
	public void setVScrollBar (boolean show) {
		sendMessage(2280, (show == true) ? 1 : 0, 0);
	}

	/**
	 * Is the vertical scroll bar visible?
	 */
	public boolean getVScrollBar () {
		return sendMessage(2281, 0, 0) == 0 ? false : true;
	}

	/**
	 * Append a string to the end of the document without changing the selection.
	 */
	public void appendText (int length, String text) {
		sendMessage(2282, length, text);
	}

	/**
	 * Is drawing done in two phases with backgrounds drawn before faoregrounds?
	 */
	public boolean getTwoPhaseDraw () {
		return sendMessage(2283, 0, 0) == 0 ? false : true;
	}

	/**
	 * In twoPhaseDraw mode, drawing is performed in two phases, first the background and then the foreground. This avoids
	 * chopping off characters that overlap the next run.
	 */
	public void setTwoPhaseDraw (boolean twoPhase) {
		sendMessage(2284, (twoPhase == true) ? 1 : 0, 0);
	}

	/**
	 * Make the target range start and end be the same as the selection range start and end.
	 */
	public void targetFromSelection () {
		sendMessage(2287, 0, 0);
	}

	/**
	 * Join the lines in the target.
	 */
	public void linesJoin () {
		sendMessage(2288, 0, 0);
	}

	/**
	 * Split the lines in the target into lines that are less wide than pixelWidth where possible.
	 */
	public void linesSplit (int pixelWidth) {
		sendMessage(2289, pixelWidth, 0);
	}

	/**
	 * Set the colours used as a chequerboard pattern in the fold margin
	 */
	public void setFoldMarginColour (boolean useSetting, int back) {
		sendMessage(2290, (useSetting == true) ? 1 : 0, back);
	}

	/**
	 * Set the colours used as a chequerboard pattern in the fold margin
	 */
	public void setFoldMarginHiColour (boolean useSetting, int fore) {
		sendMessage(2291, (useSetting == true) ? 1 : 0, fore);
	}

	/**
	 * Move caret down one line.
	 */
	public void lineDown () {
		sendMessage(2300, 0, 0);
	}

	/**
	 * Move caret down one line extending selection to new caret position.
	 */
	public void lineDownExtend () {
		sendMessage(2301, 0, 0);
	}

	/**
	 * Move caret up one line.
	 */
	public void lineUp () {
		sendMessage(2302, 0, 0);
	}

	/**
	 * Move caret up one line extending selection to new caret position.
	 */
	public void lineUpExtend () {
		sendMessage(2303, 0, 0);
	}

	/**
	 * Move caret left one character.
	 */
	public void charLeft () {
		sendMessage(2304, 0, 0);
	}

	/**
	 * Move caret left one character extending selection to new caret position.
	 */
	public void charLeftExtend () {
		sendMessage(2305, 0, 0);
	}

	/**
	 * Move caret right one character.
	 */
	public void charRight () {
		sendMessage(2306, 0, 0);
	}

	/**
	 * Move caret right one character extending selection to new caret position.
	 */
	public void charRightExtend () {
		sendMessage(2307, 0, 0);
	}

	/**
	 * Move caret left one word.
	 */
	public void wordLeft () {
		sendMessage(2308, 0, 0);
	}

	/**
	 * Move caret left one word extending selection to new caret position.
	 */
	public void wordLeftExtend () {
		sendMessage(2309, 0, 0);
	}

	/**
	 * Move caret right one word.
	 */
	public void wordRight () {
		sendMessage(2310, 0, 0);
	}

	/**
	 * Move caret right one word extending selection to new caret position.
	 */
	public void wordRightExtend () {
		sendMessage(2311, 0, 0);
	}

	/**
	 * Move caret to first position on line.
	 */
	public void home () {
		sendMessage(2312, 0, 0);
	}

	/**
	 * Move caret to first position on line extending selection to new caret position.
	 */
	public void homeExtend () {
		sendMessage(2313, 0, 0);
	}

	/**
	 * Move caret to last position on line.
	 */
	public void lineEnd () {
		sendMessage(2314, 0, 0);
	}

	/**
	 * Move caret to last position on line extending selection to new caret position.
	 */
	public void lineEndExtend () {
		sendMessage(2315, 0, 0);
	}

	/**
	 * Move caret to first position in document.
	 */
	public void documentStart () {
		sendMessage(2316, 0, 0);
	}

	/**
	 * Move caret to first position in document extending selection to new caret position.
	 */
	public void documentStartExtend () {
		sendMessage(2317, 0, 0);
	}

	/**
	 * Move caret to last position in document.
	 */
	public void documentEnd () {
		sendMessage(2318, 0, 0);
	}

	/**
	 * Move caret to last position in document extending selection to new caret position.
	 */
	public void documentEndExtend () {
		sendMessage(2319, 0, 0);
	}

	/**
	 * Move caret one page up.
	 */
	public void pageUp () {
		sendMessage(2320, 0, 0);
	}

	/**
	 * Move caret one page up extending selection to new caret position.
	 */
	public void pageUpExtend () {
		sendMessage(2321, 0, 0);
	}

	/**
	 * Move caret one page down.
	 */
	public void pageDown () {
		sendMessage(2322, 0, 0);
	}

	/**
	 * Move caret one page down extending selection to new caret position.
	 */
	public void pageDownExtend () {
		sendMessage(2323, 0, 0);
	}

	/**
	 * Switch from insert to overtype mode or the reverse.
	 */
	public void editToggleOvertype () {
		sendMessage(2324, 0, 0);
	}

	/**
	 * Cancel any modes such as call tip or auto-completion list display.
	 */
	public void cancel () {
		sendMessage(2325, 0, 0);
	}

	/**
	 * Delete the selection or if no selection, the character before the caret.
	 */
	public void deleteBack () {
		sendMessage(2326, 0, 0);
	}

	/**
	 * If selection is empty or all on one line replace the selection with a tab character. If more than one line selected,
	 * indent the lines.
	 */
	public void tab () {
		sendMessage(2327, 0, 0);
	}

	/**
	 * Dedent the selected lines.
	 */
	public void backTab () {
		sendMessage(2328, 0, 0);
	}

	/**
	 * Insert a new line, may use a CRLF, CR or LF depending on EOL mode.
	 */
	public void newLine () {
		sendMessage(2329, 0, 0);
	}

	/**
	 * Insert a Form Feed character.
	 */
	public void formFeed () {
		sendMessage(2330, 0, 0);
	}

	/**
	 * Move caret to before first visible character on line. If already there move to first character on line.
	 */
	public void vCHome () {
		sendMessage(2331, 0, 0);
	}

	/**
	 * Like VCHome but extending selection to new caret position.
	 */
	public void vCHomeExtend () {
		sendMessage(2332, 0, 0);
	}

	/**
	 * Magnify the displayed text by increasing the sizes by 1 point.
	 */
	public void zoomIn () {
		sendMessage(2333, 0, 0);
	}

	/**
	 * Make the displayed text smaller by decreasing the sizes by 1 point.
	 */
	public void zoomOut () {
		sendMessage(2334, 0, 0);
	}

	/**
	 * Delete the word to the left of the caret.
	 */
	public void delWordLeft () {
		sendMessage(2335, 0, 0);
	}

	/**
	 * Delete the word to the right of the caret.
	 */
	public void delWordRight () {
		sendMessage(2336, 0, 0);
	}

	/**
	 * Cut the line containing the caret.
	 */
	public void lineCut () {
		sendMessage(2337, 0, 0);
	}

	/**
	 * Delete the line containing the caret.
	 */
	public void lineDelete () {
		sendMessage(2338, 0, 0);
	}

	/**
	 * Switch the current line with the previous.
	 */
	public void lineTranspose () {
		sendMessage(2339, 0, 0);
	}

	/**
	 * Duplicate the current line.
	 */
	public void lineDuplicate () {
		sendMessage(2404, 0, 0);
	}

	/**
	 * Transform the selection to lower case.
	 */
	public void lowerCase () {
		sendMessage(2340, 0, 0);
	}

	/**
	 * Transform the selection to upper case.
	 */
	public void upperCase () {
		sendMessage(2341, 0, 0);
	}

	/**
	 * Scroll the document down, keeping the caret visible.
	 */
	public void lineScrollDown () {
		sendMessage(2342, 0, 0);
	}

	/**
	 * Scroll the document up, keeping the caret visible.
	 */
	public void lineScrollUp () {
		sendMessage(2343, 0, 0);
	}

	/**
	 * Delete the selection or if no selection, the character before the caret. Will not delete the character before at the
	 * start of a line.
	 */
	public void deleteBackNotLine () {
		sendMessage(2344, 0, 0);
	}

	/**
	 * Move caret to first position on display line.
	 */
	public void homeDisplay () {
		sendMessage(2345, 0, 0);
	}

	/**
	 * Move caret to first position on display line extending selection to new caret position.
	 */
	public void homeDisplayExtend () {
		sendMessage(2346, 0, 0);
	}

	/**
	 * Move caret to last position on display line.
	 */
	public void lineEndDisplay () {
		sendMessage(2347, 0, 0);
	}

	/**
	 * Move caret to last position on display line extending selection to new caret position.
	 */
	public void lineEndDisplayExtend () {
		sendMessage(2348, 0, 0);
	}

	/**
	 * These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)? except they behave differently when
	 * word-wrap is enabled: They go first to the start / end of the display line, like (Home|LineEnd)Display The difference
	 * is that, the cursor is already at the point, it goes on to the start or end of the document line, as appropriate for
	 * (Home|LineEnd|VCHome)(Extend)?.
	 */
	public void homeWrap () {
		sendMessage(2349, 0, 0);
	}

	/**
	 * These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)? except they behave differently when
	 * word-wrap is enabled: They go first to the start / end of the display line, like (Home|LineEnd)Display The difference
	 * is that, the cursor is already at the point, it goes on to the start or end of the document line, as appropriate for
	 * (Home|LineEnd|VCHome)(Extend)?.
	 */
	public void homeWrapExtend () {
		sendMessage(2450, 0, 0);
	}

	/**
	 * These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)? except they behave differently when
	 * word-wrap is enabled: They go first to the start / end of the display line, like (Home|LineEnd)Display The difference
	 * is that, the cursor is already at the point, it goes on to the start or end of the document line, as appropriate for
	 * (Home|LineEnd|VCHome)(Extend)?.
	 */
	public void lineEndWrap () {
		sendMessage(2451, 0, 0);
	}

	/**
	 * These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)? except they behave differently when
	 * word-wrap is enabled: They go first to the start / end of the display line, like (Home|LineEnd)Display The difference
	 * is that, the cursor is already at the point, it goes on to the start or end of the document line, as appropriate for
	 * (Home|LineEnd|VCHome)(Extend)?.
	 */
	public void lineEndWrapExtend () {
		sendMessage(2452, 0, 0);
	}

	/**
	 * These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)? except they behave differently when
	 * word-wrap is enabled: They go first to the start / end of the display line, like (Home|LineEnd)Display The difference
	 * is that, the cursor is already at the point, it goes on to the start or end of the document line, as appropriate for
	 * (Home|LineEnd|VCHome)(Extend)?.
	 */
	public void vCHomeWrap () {
		sendMessage(2453, 0, 0);
	}

	/**
	 * These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)? except they behave differently when
	 * word-wrap is enabled: They go first to the start / end of the display line, like (Home|LineEnd)Display The difference
	 * is that, the cursor is already at the point, it goes on to the start or end of the document line, as appropriate for
	 * (Home|LineEnd|VCHome)(Extend)?.
	 */
	public void vCHomeWrapExtend () {
		sendMessage(2454, 0, 0);
	}

	/**
	 * Copy the line containing the caret.
	 */
	public void lineCopy () {
		sendMessage(2455, 0, 0);
	}

	/**
	 * Move the caret inside current view if it's not there already.
	 */
	public void moveCaretInsideView () {
		sendMessage(2401, 0, 0);
	}

	/**
	 * How many characters are on a line, not including end of line characters?
	 */
	public int lineLength (int line) {
		return sendMessage(2350, line, 0);
	}

	/**
	 * Highlight the characters at two positions.
	 */
	public void braceHighlight (int pos1, int pos2) {
		sendMessage(2351, pos1, pos2);
	}

	/**
	 * Highlight the character at a position indicating there is no matching brace.
	 */
	public void braceBadLight (int pos) {
		sendMessage(2352, pos, 0);
	}

	/**
	 * Find the position of a matching brace or INVALID_POSITION if no match.
	 */
	public int braceMatch (int pos) {
		return sendMessage(2353, pos, 0);
	}

	/**
	 * Are the end of line characters visible?
	 */
	public boolean getViewEOL () {
		return sendMessage(2355, 0, 0) == 0 ? false : true;
	}

	/**
	 * Make the end of line characters visible or invisible.
	 */
	public void setViewEOL (boolean visible) {
		sendMessage(2356, (visible == true) ? 1 : 0, 0);
	}

	/**
	 * Retrieve a pointer to the document object.
	 */
	public int getDocPointer () {
		return sendMessage(2357, 0, 0);
	}

	/**
	 * Change the document object used. NOTE: You should pass zero as wParam.
	 */
	public void setDocPointer (int pointer) {
		sendMessage(2358, 0, pointer);
	}

	/**
	 * Set which document modification events are sent to the container.
	 */
	public void setModEventMask (int mask) {
		sendMessage(2359, mask, 0);
	}

	/**
	 * Retrieve the column number which text should be kept within.
	 */
	public int getEdgeColumn () {
		return sendMessage(2360, 0, 0);
	}

	/**
	 * Set the column number of the edge. If text goes past the edge then it is highlighted.
	 */
	public void setEdgeColumn (int column) {
		sendMessage(2361, column, 0);
	}

	/**
	 * Retrieve the edge highlight mode.
	 */
	public int getEdgeMode () {
		return sendMessage(2362, 0, 0);
	}

	/**
	 * The edge may be displayed by a line (EDGE_LINE) or by highlighting text that goes beyond it (EDGE_BACKGROUND) or not
	 * displayed at all (EDGE_NONE).
	 */
	public void setEdgeMode (int mode) {
		sendMessage(2363, mode, 0);
	}

	/**
	 * Retrieve the colour used in edge indication.
	 */
	public int getEdgeColour () {
		return sendMessage(2364, 0, 0);
	}

	/**
	 * Change the colour used in edge indication.
	 */
	public void setEdgeColour (int edgeColour) {
		sendMessage(2365, edgeColour, 0);
	}

	/**
	 * Sets the current caret position to be the search anchor.
	 */
	public void searchAnchor () {
		sendMessage(2366, 0, 0);
	}

	/**
	 * Find some text starting at the search anchor. Does not ensure the selection is visible.
	 */
	public int searchNext (int flags, String text) {
		return sendMessage(2367, flags, text);
	}

	/**
	 * Find some text starting at the search anchor and moving backwards. Does not ensure the selection is visible.
	 */
	public int searchPrev (int flags, String text) {
		return sendMessage(2368, flags, text);
	}

	/**
	 * Retrieves the number of lines completely visible.
	 */
	public int linesOnScreen () {
		return sendMessage(2370, 0, 0);
	}

	/**
	 * Set whether a pop up menu is displayed automatically when the user presses the wrong mouse button.
	 */
	public void usePopUp (boolean allowPopUp) {
		sendMessage(2371, (allowPopUp == true) ? 1 : 0, 0);
	}

	/**
	 * Is the selection rectangular? The alternative is the more common stream selection.
	 */
	public boolean selectionIsRectangle () {
		return sendMessage(2372, 0, 0) == 0 ? false : true;
	}

	/**
	 * Set the zoom level. This number of points is added to the size of all fonts. It may be positive to magnify or negative
	 * to reduce.
	 */
	public void setZoom (int zoom) {
		sendMessage(2373, zoom, 0);
	}

	/**
	 * Retrieve the zoom level.
	 */
	public int getZoom () {
		return sendMessage(2374, 0, 0);
	}

	/**
	 * Create a new document object. Starts with reference count of 1 and not selected into editor.
	 */
	public int createDocument () {
		return sendMessage(2375, 0, 0);
	}

	/**
	 * Extend life of document. NOTE: You should pass zero as wParam.
	 */
	public void addRefDocument (int doc) {
		sendMessage(2376, 0, doc);
	}

	/**
	 * Release a reference to the document, deleting document if it fades to black. NOTE: You should pass zero as wParam.
	 */
	public void releaseDocument (int doc) {
		sendMessage(2377, 0, doc);
	}

	/**
	 * Get which document modification events are sent to the container.
	 */
	public int getModEventMask () {
		return sendMessage(2378, 0, 0);
	}

	/**
	 * Change internal focus flag.
	 */
	public void setFocus (boolean focus) {
		sendMessage(2380, (focus == true) ? 1 : 0, 0);
	}

	/**
	 * Get internal focus flag.
	 */
	public boolean getFocus () {
		return sendMessage(2381, 0, 0) == 0 ? false : true;
	}

	/**
	 * Change error status - 0 = OK.
	 */
	public void setStatus (int statusCode) {
		sendMessage(2382, statusCode, 0);
	}

	/**
	 * Get error status.
	 */
	public int getStatus () {
		return sendMessage(2383, 0, 0);
	}

	/**
	 * Set whether the mouse is captured when its button is pressed.
	 */
	public void setMouseDownCaptures (boolean captures) {
		sendMessage(2384, (captures == true) ? 1 : 0, 0);
	}

	/**
	 * Get whether mouse gets captured.
	 */
	public boolean getMouseDownCaptures () {
		return sendMessage(2385, 0, 0) == 0 ? false : true;
	}

	/**
	 * Sets the cursor to one of the SC_CURSOR* values.
	 */
	public void setCursor (int cursorType) {
		sendMessage(2386, cursorType, 0);
	}

	/**
	 * Get cursor type.
	 */
	public int getCursor () {
		return sendMessage(2387, 0, 0);
	}

	/**
	 * Change the way control characters are displayed: If symbol is < 32, keep the drawn way, else, use the given character.
	 */
	public void setControlCharSymbol (int symbol) {
		sendMessage(2388, symbol, 0);
	}

	/**
	 * Get the way control characters are displayed.
	 */
	public int getControlCharSymbol () {
		return sendMessage(2389, 0, 0);
	}

	/**
	 * Move to the previous change in capitalisation.
	 */
	public void wordPartLeft () {
		sendMessage(2390, 0, 0);
	}

	/**
	 * Move to the previous change in capitalisation extending selection to new caret position.
	 */
	public void wordPartLeftExtend () {
		sendMessage(2391, 0, 0);
	}

	/**
	 * Move to the change next in capitalisation.
	 */
	public void wordPartRight () {
		sendMessage(2392, 0, 0);
	}

	/**
	 * Move to the next change in capitalisation extending selection to new caret position.
	 */
	public void wordPartRightExtend () {
		sendMessage(2393, 0, 0);
	}

	/**
	 * Set the way the display area is determined when a particular line is to be moved to by Find, FindNext, GotoLine, etc.
	 */
	public void setVisiblePolicy (int visiblePolicy, int visibleSlop) {
		sendMessage(2394, visiblePolicy, visibleSlop);
	}

	/**
	 * Delete back from the current position to the start of the line.
	 */
	public void delLineLeft () {
		sendMessage(2395, 0, 0);
	}

	/**
	 * Delete forwards from the current position to the end of the line.
	 */
	public void delLineRight () {
		sendMessage(2396, 0, 0);
	}

	/**
	 * Get and Set the xOffset (ie, horizonal scroll position).
	 */
	public void setXOffset (int newOffset) {
		sendMessage(2397, newOffset, 0);
	}

	/**
	 * Get and Set the xOffset (ie, horizonal scroll position).
	 */
	public int getXOffset () {
		return sendMessage(2398, 0, 0);
	}

	/**
	 * Set the last x chosen value to be the caret x position.
	 */
	public void chooseCaretX () {
		sendMessage(2399, 0, 0);
	}

	/**
	 * Set the focus to this Scintilla widget. GTK+ Specific.
	 */
	public void grabFocus () {
		sendMessage(2400, 0, 0);
	}

	/**
	 * Set the way the caret is kept visible when going sideway. The exclusion zone is given in pixels.
	 */
	public void setXCaretPolicy (int caretPolicy, int caretSlop) {
		sendMessage(2402, caretPolicy, caretSlop);
	}

	/**
	 * Set the way the line the caret is on is kept visible. The exclusion zone is given in lines.
	 */
	public void setYCaretPolicy (int caretPolicy, int caretSlop) {
		sendMessage(2403, caretPolicy, caretSlop);
	}

	/**
	 * Set printing to line wrapped (SC_WRAP_WORD) or not line wrapped (SC_WRAP_NONE).
	 */
	public void setPrintWrapMode (int mode) {
		sendMessage(2406, mode, 0);
	}

	/**
	 * Is printing line wrapped?
	 */
	public int getPrintWrapMode () {
		return sendMessage(2407, 0, 0);
	}

	/**
	 * Set a fore colour for active hotspots.
	 */
	public void setHotspotActiveFore (boolean useSetting, int fore) {
		sendMessage(2410, (useSetting == true) ? 1 : 0, fore);
	}

	/**
	 * Set a back colour for active hotspots.
	 */
	public void setHotspotActiveBack (boolean useSetting, int back) {
		sendMessage(2411, (useSetting == true) ? 1 : 0, back);
	}

	/**
	 * Enable / Disable underlining active hotspots.
	 */
	public void setHotspotActiveUnderline (boolean underline) {
		sendMessage(2412, (underline == true) ? 1 : 0, 0);
	}

	/**
	 * Limit hotspots to single line so hotspots on two lines don't merge.
	 */
	public void setHotspotSingleLine (boolean singleLine) {
		sendMessage(2421, (singleLine == true) ? 1 : 0, 0);
	}

	/**
	 * Move caret between paragraphs (delimited by empty lines).
	 */
	public void paraDown () {
		sendMessage(2413, 0, 0);
	}

	/**
	 * Move caret between paragraphs (delimited by empty lines).
	 */
	public void paraDownExtend () {
		sendMessage(2414, 0, 0);
	}

	/**
	 * Move caret between paragraphs (delimited by empty lines).
	 */
	public void paraUp () {
		sendMessage(2415, 0, 0);
	}

	/**
	 * Move caret between paragraphs (delimited by empty lines).
	 */
	public void paraUpExtend () {
		sendMessage(2416, 0, 0);
	}

	/**
	 * Given a valid document position, return the previous position taking code page into account. Returns 0 if passed 0.
	 */
	public int positionBefore (int pos) {
		return sendMessage(2417, pos, 0);
	}

	/**
	 * Given a valid document position, return the next position taking code page into account. Maximum value returned is the
	 * last position in the document.
	 */
	public int positionAfter (int pos) {
		return sendMessage(2418, pos, 0);
	}

	/**
	 * Copy a range of text to the clipboard. Positions are clipped into the document.
	 */
	public void copyRange (int start, int end) {
		sendMessage(2419, start, end);
	}

	/**
	 * Copy argument text to the clipboard.
	 */
	public void copyText (int length, String text) {
		sendMessage(2420, length, text);
	}

	/**
	 * Set the selection mode to stream (SC_SEL_STREAM) or rectangular (SC_SEL_RECTANGLE) or by lines (SC_SEL_LINES).
	 */
	public void setSelectionMode (int mode) {
		sendMessage(2422, mode, 0);
	}

	/**
	 * Get the mode of the current selection.
	 */
	public int getSelectionMode () {
		return sendMessage(2423, 0, 0);
	}

	/**
	 * Retrieve the position of the start of the selection at the given line (INVALID_POSITION if no selection on this line).
	 */
	public int getLineSelStartPosition (int line) {
		return sendMessage(2424, line, 0);
	}

	/**
	 * Retrieve the position of the end of the selection at the given line (INVALID_POSITION if no selection on this line).
	 */
	public int getLineSelEndPosition (int line) {
		return sendMessage(2425, line, 0);
	}

	/**
	 * Move caret down one line, extending rectangular selection to new caret position.
	 */
	public void lineDownRectExtend () {
		sendMessage(2426, 0, 0);
	}

	/**
	 * Move caret up one line, extending rectangular selection to new caret position.
	 */
	public void lineUpRectExtend () {
		sendMessage(2427, 0, 0);
	}

	/**
	 * Move caret left one character, extending rectangular selection to new caret position.
	 */
	public void charLeftRectExtend () {
		sendMessage(2428, 0, 0);
	}

	/**
	 * Move caret right one character, extending rectangular selection to new caret position.
	 */
	public void charRightRectExtend () {
		sendMessage(2429, 0, 0);
	}

	/**
	 * Move caret to first position on line, extending rectangular selection to new caret position.
	 */
	public void homeRectExtend () {
		sendMessage(2430, 0, 0);
	}

	/**
	 * Move caret to before first visible character on line. If already there move to first character on line. In either case,
	 * extend rectangular selection to new caret position.
	 */
	public void vCHomeRectExtend () {
		sendMessage(2431, 0, 0);
	}

	/**
	 * Move caret to last position on line, extending rectangular selection to new caret position.
	 */
	public void lineEndRectExtend () {
		sendMessage(2432, 0, 0);
	}

	/**
	 * Move caret one page up, extending rectangular selection to new caret position.
	 */
	public void pageUpRectExtend () {
		sendMessage(2433, 0, 0);
	}

	/**
	 * Move caret one page down, extending rectangular selection to new caret position.
	 */
	public void pageDownRectExtend () {
		sendMessage(2434, 0, 0);
	}

	/**
	 * Move caret to top of page, or one page up if already at top of page.
	 */
	public void stutteredPageUp () {
		sendMessage(2435, 0, 0);
	}

	/**
	 * Move caret to top of page, or one page up if already at top of page, extending selection to new caret position.
	 */
	public void stutteredPageUpExtend () {
		sendMessage(2436, 0, 0);
	}

	/**
	 * Move caret to bottom of page, or one page down if already at bottom of page.
	 */
	public void stutteredPageDown () {
		sendMessage(2437, 0, 0);
	}

	/**
	 * Move caret to bottom of page, or one page down if already at bottom of page, extending selection to new caret position.
	 */
	public void stutteredPageDownExtend () {
		sendMessage(2438, 0, 0);
	}

	/**
	 * Move caret left one word, position cursor at end of word.
	 */
	public void wordLeftEnd () {
		sendMessage(2439, 0, 0);
	}

	/**
	 * Move caret left one word, position cursor at end of word, extending selection to new caret position.
	 */
	public void wordLeftEndExtend () {
		sendMessage(2440, 0, 0);
	}

	/**
	 * Move caret right one word, position cursor at end of word.
	 */
	public void wordRightEnd () {
		sendMessage(2441, 0, 0);
	}

	/**
	 * Move caret right one word, position cursor at end of word, extending selection to new caret position.
	 */
	public void wordRightEndExtend () {
		sendMessage(2442, 0, 0);
	}

	/**
	 * Set the set of characters making up whitespace for when moving or selecting by word. Should be called after
	 * SetWordChars. NOTE: You should pass zero as wParam.
	 */
	public void setWhitespaceChars (String characters) {
		sendMessage(2443, 0, characters);
	}

	/**
	 * Reset the set of characters for whitespace and word characters to the defaults.
	 */
	public void setCharsDefault () {
		sendMessage(2444, 0, 0);
	}

	/**
	 * Get currently selected item position in the auto-completion list
	 */
	public int autoCGetCurrent () {
		return sendMessage(2445, 0, 0);
	}

	/**
	 * Enlarge the document to a particular size of text bytes.
	 */
	public void allocate (int bytes) {
		sendMessage(2446, bytes, 0);
	}

	/**
	 * Start notifying the container of all key presses and commands.
	 */
	public void startRecord () {
		sendMessage(3001, 0, 0);
	}

	/**
	 * Stop notifying the container of all key presses and commands.
	 */
	public void stopRecord () {
		sendMessage(3002, 0, 0);
	}

	/**
	 * Set the lexing language of the document.
	 */
	public void setLexer (int lexer) {
		sendMessage(4001, lexer, 0);
	}

	/**
	 * Retrieve the lexing language of the document.
	 */
	public int getLexer () {
		return sendMessage(4002, 0, 0);
	}

	/**
	 * Colourise a segment of the document using the current lexing language.
	 */
	public void colourise (int start, int end) {
		sendMessage(4003, start, end);
	}

	/**
	 * Set up a value that may be used by a lexer for some optional feature.
	 */
	public void setProperty (String key, String value) {
		sendMessage(4004, key, value);
	}

	/**
	 * Set up the key words used by the lexer.
	 */
	public void setKeyWords (int keywordSet, String keyWords) {
		sendMessage(4005, keywordSet, keyWords);
	}

	/**
	 * Set the lexing language of the document based on string name. NOTE: You should pass zero as wParam.
	 */
	public void setLexerLanguage (String language) {
		sendMessage(4006, 0, language);
	}

	/**
	 * Load a lexer library (dll / so). NOTE: You should pass zero as wParam.
	 */
	public void loadLexerLibrary (String path) {
		sendMessage(4007, 0, path);
	}

	/**
	 * CARET_POLICY changed in 1.47
	 * @deprecated
	 */
	public void setCaretPolicy (int caretPolicy, int caretSlop) {
		sendMessage(2369, caretPolicy, caretSlop);
	}

	// --Autogenerated
}
